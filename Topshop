-- Anti-cheat event bypass script with remote blocking
local eventbypass

eventbypass = hookmetamethod(game, "__namecall", function(self, ...)
    local method = getnamecallmethod()

    if not checkcaller() then
        if method == "FireServer" then
            -- Check if this remote is not in the ignored list and block it if detected
            if knownRemotes[self:GetDebugId()] then
                print("Blocked remote call to:", self.Name)
                return wait(9e9)  -- Block the remote by pausing execution indefinitely
            end
        end
    end

    return eventbypass(self, ...)
end)

-- Get player and disable specified scripts
local PlayersService = game:GetService("Players")
local player = PlayersService:FindFirstChild("1_ALsfaH")

if player then
    local playerScripts = player:FindFirstChild("PlayerScripts")
    
    if playerScripts then
        local acBackup = playerScripts:FindFirstChild("AC_Backup")
        local acPlayer = playerScripts:FindFirstChild("AC_Player")
        local playerControl = playerScripts:FindFirstChild("PlayerControl")

        if acBackup then
            acBackup.Disabled = true
            print("Disabled script:", acBackup:GetFullName())
        else
            warn("AC_Backup script not found.")
        end

        if acPlayer then
            acPlayer.Disabled = true
            print("Disabled script:", acPlayer:GetFullName())
        else
            warn("AC_Player script not found.")
        end

        if playerControl then
            playerControl.Disabled = true
            print("Disabled script:", playerControl:GetFullName())
        else
            warn("PlayerControl script not found.")
        end
    else
        warn("PlayerScripts not found in the player.")
    end
else
    warn("Player '1_ALsfaH' not found.")
end

-- Remote detection with ignore list and blocking mechanism
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local targetParent = ReplicatedStorage:FindFirstChild("Remotes")

-- List of remotes to ignore by their name
local ignoredRemotes = {
    "AcceptTradeRequestEvent",
    "AdminAppEvent",
    "AdminBtnsrEvent",
    "AlrajhiAppEvent",
    "AlrajhiWithdrawDeposit",
    "AsefneAcceptEvent",
    "AsefneFinishEvent",
    "AsefneRequestEvent",
    "BanAppCheakBanEvent",
    "BanAppGiveBanEvent",
    "BanAppRemvBanEvent",
    "BuyClothEvent",
    "BuyShopEvent",
    "CancelTradeRequestEvent",
    "CarShopSellEvent",
    "CarShopSpawnEvent",
    "CarsGarageSpawnEvent",
    "CarsShopBuyEvent",
    "ChangeGuiTextAndColorEvent",
    "ChangeGuiVisibleEvent",
    "ChangePlayerCameraEvent",
    "ChangeServerPropertiesEvent",
    "CloseTradeRequestEvent",
    "ClothsShopBuyEvent",
    "ClothsShopCharsBtnEvent",
    "ClothsShopRestCharEvent",
    "ClothsShopUpdateCharEvent",
    "ClothsShopUpdateGuiEvent",
    "ClothsShopUseEvent",
    "CraftItemCraftingTableEvent",
    "CreateCharFinishEvent",
    "CreateNewToolEvent",
    "CreateCharUpdateEvent",
    "CropPlantEvent",
    "DeliverCargoEvent",
    "DisablePlayerEvent",
    "DoctorReviveEvent",
    "DoctorHealEvent",
    "DrawWayPointsEvent",
    "FinishTradeRequestEvent",
    "FireJobMemberListEvent",
    "ForceStopAnimsEvent",
    "GetJobMemberListEvent",
    "GiveFineEvent",
    "GivePlayerJobPointsEvent",
    "GiveReportEvent",
    "GvePlayerBehivePointsEvent",
    "HideShowClothsEvent",
    "HumPropValidEvent",
    "InventoryAddToolEvent",
    "InventoryDestroyEvent",
    "InventoryGetTargetEvent",
    "InventoryRemvToolEvent",
    "InventoryRighClickEvent",
    "InventorySwapEvent",
    "JobDeviceFireEvent",
    "JobDeviceHairEvent",
    "JobSelectEvent",
    "JobUpgradeEvent",
    "KidnappingEvent",
    "LockTradeRequestEvent",
    "LockpickPrisonOpen",
    "LockpickTargetUnlockEvent",
    "MoveToolToBagEvent",
    "OpenGarageJobEvent",
    "OpenShopEvent",
    "OpenWhereHouseEvent",
    "PartPropValidEvent",
    "PickupCargoEvent",
    "PlayAnimsEvent",
    "PlaySoundToPlayerEvent",
    "PlayerPrisonFromDiffScript",
    "PoliceCarryEvent",
    "PoliceGiveFine",
    "PoliceHandCuffEvent",
    "PoliceSendPrisonEvent",
    "PoliceSerchEvent",
    "PoliceUnHandCuffEvent",
    "PopGuiEvent",
    "ProfileRestStateEvent",
    "ProfileUpStateEvent",
    "RadioEnterEvent",
    "RadioLeaveEvent",
    "RadioSendMsgEvent",
    "ReducePlayerLaborEvent",
    "ReflectTradeRequestEvent",
    "ResourceSellEvent",
    "RunWorldEvent",
    "SalaryNotifiyEvent",
    "SendTradeRequestEvent",
    "ShopGemsBuyEvents",
    "StealShopEvent",
    "SpawnGarageJobEvent",
    "StoreCarToPlrCarsEvent",
    "ToolHealthReduceClintEvent",
    "ToolHealthReduceServerEvent",
    "UnHandCuffGuiBtnEvent",
    "UpDateVipJobsEvent",
    "changeClientPropertiesEvent"
}

-- Table to store last known names of detected remotes
local knownRemotes = {}

-- Check each remote once and block if not ignored
if targetParent then
    for _, child in pairs(targetParent:GetChildren()) do
        if child:IsA("RemoteEvent") then
            local currentName = child.Name

            -- Skip and allow if the remote is in the ignored list
            if not table.find(ignoredRemotes, currentName) then
                -- Print the remote's name if it's not in the ignored list
                print("Detected and blocked remote: " .. currentName)

                -- Store this remote in knownRemotes for blocking in the eventbypass
                knownRemotes[child:GetDebugId()] = currentName
            end
        end
    end
else
    print("No 'Remotes' folder found in ReplicatedStorage.")
end

print("Script execution completed.")
local username = game.Players.LocalPlayer.Name -- Get the local player's username

-- Function to check if the player has permission
local function hasPermission(playerName)
    -- Define the list of permitted usernames
    local permittedUsers = {
        "seliem779", -- Replace with actual usernames
        "1_ALsfaH",
        -- Add more usernames as needed
    }

    -- Check if the username is in the permittedUsers list
    for _, user in ipairs(permittedUsers) do
        if playerName == user then
            return true
        end
    end
    return false
end

-- Check if the local player has permission
if not hasPermission(username) then
    game.Players.LocalPlayer:Kick("تبي تهكر؟")
    return -- Exit the script if the player is kicked
end

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Top City",
    SubTitle = "By Ahmed",
    TabWidth = 100,
    Size = UDim2.fromOffset(320, 170),
    Acrylic = true,
    Theme = "Dark"
})

-- Tab for Kill Options
local Tab1 = Window:AddTab({ Title = "قتل تلقائي", Icon = "" })

-- Variable to store the target player's name
local playerName = ""

-- Textbox for entering the target player's username
Tab1:AddInput("Input", {
    Title = "",
    Default = "",
    Placeholder = "Enter username",
    Numeric = false,
    Finished = false,
    Callback = function(Value)
        playerName = Value  -- Update the playerName variable with user input
        print("Target set to: " .. playerName)
    end
})

-- Kill Button
Tab1:AddButton({
    Title = "قتل الاعب",
    Callback = function()
        local localPlayer = game.Players.LocalPlayer
        local weapon = localPlayer.Character:FindFirstChildOfClass("Tool")

        if weapon and playerName ~= "" then
            for i = 1, 4 do
                local targetPlayer = game.Players:FindFirstChild(playerName)

                if targetPlayer and targetPlayer.Character then
                    local args = {
                        [1] = weapon,
                        [2] = {
                            ["p"] = Vector3.new(635.4351806640625, 37.73330307006836, -783.640625),
                            ["pid"] = 1,
                            ["part"] = targetPlayer.Character.HumanoidRootPart,
                            ["d"] = 43.0,
                        }
                    }

                    game:GetService("ReplicatedStorage").WeaponsSystem.Network.WeaponHit:FireServer(unpack(args))
                else
                    print("Target player not found.")
                    break
                end
            end
        else
            print("Weapon not found or player name is empty.")
        end
    end
})

-- Kill Button 2
Tab1:AddButton({
    Title = "قتل الاعب2",
    Callback = function()
        local localPlayer = game.Players.LocalPlayer
        local weapon = localPlayer.Character:FindFirstChildOfClass("Tool")

        if weapon and playerName ~= "" then
            for i = 1, 1 do
                local targetPlayer = game.Players:FindFirstChild(playerName)

                if targetPlayer and targetPlayer.Character then
                    local args = {
                        [1] = weapon,
                        [2] = {
                            ["p"] = Vector3.new(635.4351806640625, 37.73330307006836, -783.640625),
                            ["pid"] = 1,
                            ["part"] = targetPlayer.Character.HumanoidRootPart,
                            ["d"] = 43.0,
                        }
                    }

                    game:GetService("ReplicatedStorage").WeaponsSystem.Network.WeaponHit:FireServer(unpack(args))
                else
                    print("Target player not found.")
                    break
                end
            end
        else
            print("Weapon not found or player name is empty.")
        end
    end
})

-- New Tab for Tree Options
local Tab2 = Window:AddTab({ Title = "التجميع", Icon = "" })

-- Max Button for Wine
Tab2:AddButton({
    Title = "العنب",
    Callback = function()
        local prompts = {
            workspace.MyScripts.WorldMats.WineFarm:GetChildren()[18].Prompt,
            workspace.MyScripts.WorldMats.WineFarm:GetChildren()[16].Prompt,
            workspace.MyScripts.WorldMats.WineFarm:GetChildren()[9].Prompt,
            workspace.MyScripts.WorldMats.WineFarm:GetChildren()[15].Prompt,
            workspace.MyScripts.WorldMats.WineFarm:GetChildren()[14].Prompt,
            workspace.MyScripts.WorldMats.WineFarm:GetChildren()[13].Prompt,
            workspace.MyScripts.WorldMats.WineFarm:GetChildren()[12].Prompt,
            workspace.MyScripts.WorldMats.WineFarm:GetChildren()[11].Prompt,
            workspace.MyScripts.WorldMats.WineFarm:GetChildren()[8].Prompt,
            workspace.MyScripts.WorldMats.WineFarm:GetChildren()[17].Prompt,
            workspace.MyScripts.WorldMats.WineFarm:GetChildren()[10].Prompt,
            workspace.MyScripts.WorldMats.WineFarm:GetChildren()[4].Prompt,
            workspace.MyScripts.WorldMats.WineFarm:GetChildren()[5].Prompt,
            workspace.MyScripts.WorldMats.WineFarm:GetChildren()[6].Prompt,
            workspace.MyScripts.WorldMats.WineFarm:GetChildren()[7].Prompt,
            workspace.MyScripts.WorldMats.WineFarm.GraphTree.Prompt,
        }

        for _, prompt in ipairs(prompts) do
            prompt.HoldDuration = 0
            prompt.Exclusivity = Enum.ProximityPromptExclusivity.AlwaysShow
        end

        -- Set MaxActivationDistance for each prompt
        local maxActivationDistance = 10000
        for _, child in ipairs(workspace.MyScripts.WorldMats.WineFarm:GetChildren()) do
            local prompt = child:FindFirstChildOfClass("ProximityPrompt")
            if prompt then
                prompt.MaxActivationDistance = maxActivationDistance
                prompt.Exclusivity = Enum.ProximityPromptExclusivity.AlwaysShow
            end
        end

        print("All tree prompts have been updated.")
    end
})

-- New Button for Stones
Tab2:AddButton({
    Title = "تجميع الصخر",
    Callback = function()
        local stones = workspace.MyScripts.WorldMats.Stones

        -- Loop through indices 0 to 100
        for index = 0, 100 do
            local child = stones:GetChildren()[index + 1]  -- +1 for 1-based indexing
            if child and child:FindFirstChild("Prompt") then
                local proximityPrompt = child.Prompt:FindFirstChildOfClass("ProximityPrompt")
                if proximityPrompt then
                    proximityPrompt.HoldDuration = 0
                    proximityPrompt.Exclusivity = Enum.ProximityPromptExclusivity.AlwaysShow
                    proximityPrompt.MaxActivationDistance = 10000
                end
            end
        end

        print("All stone prompts have been updated.")
    end
})

Fluent:Notify({
    Title = "السكربت",
    Content = "The script has been loaded.",
    Duration = 5
})

